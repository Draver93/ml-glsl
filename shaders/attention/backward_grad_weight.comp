#version 430
layout(local_size_x = 16, local_size_y = 16) in;

layout(std430) readonly buffer CachedInput { float cached_input[]; };       // [model_dim, seq_len]
layout(std430) readonly buffer GradProjection { float grad_projection[]; }; // [model_dim, seq_len]
layout(std430) writeonly buffer GradWeight { float grad_weight[]; };        // [model_dim, model_dim]

uniform int seq_len;
uniform int input_dim;
uniform int head_dim;

void main() {
    uint input_dim_idx = gl_GlobalInvocationID.x;  // input dimension (row index)
    uint head_dim_idx = gl_GlobalInvocationID.y;   // head dimension (column index)
    
    if (input_dim_idx >= input_dim || head_dim_idx >= head_dim) return;
    
    // Compute gradient w.r.t. weight: grad_weight = input^T @ grad_projection
    // This accumulates gradients across all sequence positions
    float sum = 0.0;
    for (uint seq_pos = 0; seq_pos < seq_len; seq_pos++) {
        // input^T indexing: input^T[input_dim_idx, seq_pos] = input[seq_pos, input_dim_idx]
        // Row-major indexing: input[seq_pos * input_dim + input_dim_idx]
        uint input_row_major_idx = seq_pos * input_dim + input_dim_idx;
        // grad_projection indexing: [seq_pos * model_dim + head_dim_idx]
        uint grad_proj_row_major_idx = seq_pos * input_dim + head_dim_idx;
        sum += cached_input[input_row_major_idx] * grad_projection[grad_proj_row_major_idx];
    }
    
    // Store gradient with standard matrix indexing: [input_dimension * head_dimension]
    uint grad_weight_idx = input_dim_idx * head_dim + head_dim_idx;
    grad_weight[grad_weight_idx] = sum;
}