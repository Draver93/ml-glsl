#version 430
layout(local_size_x = 16, local_size_y = 16) in;

layout(std430) readonly buffer BufferQ { float Q[]; };       // [seq_len * head_dim]
layout(std430) readonly buffer BufferK { float K[]; };       // [seq_len * head_dim]
layout(std430) readonly buffer BufferV { float V[]; };       // [seq_len * head_dim]

layout(std430) writeonly buffer BufferOutput { float output_buffer[]; };  // [seq_len * head_dim]

uniform int seq_len;
uniform int head_dim;
uniform float inv_sqrt_head_dim;

void main() {
    uint seq_idx = gl_GlobalInvocationID.x;   // query position (row in Q)
    uint dim_idx = gl_GlobalInvocationID.y;   // dimension in head_dim

    if (seq_idx >= uint(seq_len) || dim_idx >= uint(head_dim)) return;

    // 1) Find max score for softmax
    float max_score = -3.402823e38; // -FLT_MAX
    for (int j = 0; j < seq_len; j++) {
        // Dot product Q[seq_idx] and K[j]
        float score = 0.0;
        for (int d = 0; d < head_dim; d++) {
            score += Q[seq_idx * head_dim + d] * K[j * head_dim + d];
        }
        score *= inv_sqrt_head_dim;
        if (score > max_score) max_score = score;
    }

    // 2) Compute denominator (sum of exp)
    float denom = 0.0;
    for (int j = 0; j < seq_len; j++) {
        float score = 0.0;
        for (int d = 0; d < head_dim; d++) {
            score += Q[seq_idx * head_dim + d] * K[j * head_dim + d];
        }
        score *= inv_sqrt_head_dim;
        denom += exp(score - max_score);
    }

    // 3) Compute final output (AttentionOutput[seq_idx, dim_idx])
    float attn_output = 0.0;
    for (int j = 0; j < seq_len; j++) {
        float score = 0.0;
        for (int d = 0; d < head_dim; d++) {
            score += Q[seq_idx * head_dim + d] * K[j * head_dim + d];
        }
        score *= inv_sqrt_head_dim;

        float weight = exp(score - max_score) / denom;

        attn_output += weight * V[j * head_dim + dim_idx];
    }

    output_buffer[seq_idx * head_dim + dim_idx] = attn_output;
}